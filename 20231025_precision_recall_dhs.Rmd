---
title: "Precision and recall analysis"
output: html_document
author: Max Dippel
date: "2023-10-25"
---

The goal of this rmd is to get precision and recall heat maps to try and develop an empirical method to classify emVars. 

This version will use pcre_p for DHS as the fill instead of precision and recall based on PICS values and the x-axis will be FC Log Adj p-value which is used to calculate pCREs. The pcre_p value is based on the variant category for pCREs. 


```{r, echo=FALSE, message=FALSE}
# loading packages
library(tidyverse)
library(RColorBrewer)
library(rmarkdown)
library(GenomicRanges)
```

# HTML version

This is the place in the html you can tell which mpra data set and specific filters are being used. In the Rmd there are multiple options and you need to delete ", eval=FALSE, echo=FALSE" from the R chunk you want to use. This will make that R chunk be used in the making of the html and display that code chunk in the html. To create the html with the correct mpra loading code chunk, you need to do to run the render chunk which is directly below it. Keep the render chunk " eval=FALSE, Echo=FALSE" so it does not appear in the html. 

```{r, eval=FALSE, echo=FALSE}
# This html version uses the mpra data from 20230825_mpra_merge_Tcell_glm_john
# This html version has no filter 
mpra.dir <- "/nfs/jray/screens/ALL_MPRAs/Ho_et_al_analysis/Downstream_Analysis/20230825_stimulated_primary_Tcell_glm_replication/john_filter/data/20230825_mpra_merge_Tcell_glm_john.txt"
mpra <- read.table(mpra.dir, sep="\t", header=T)
mpra_name <- "20230825_mpra_merge_Tcell_glm_john"
filter <- "none"
```

```{r, eval=FALSE, echo=FALSE}
# These are the different options for saving the html. They depend on the values mpra_name and filter.
# This is going to be the default 
if(filter == "none" & mpra_name == "20230825_mpra_merge_Tcell_glm_john"){
  render("20231025_precision_recall_dhs.Rmd",output_file = paste0(mpra_name, "_precision_recall_dhs",".html"))
}
```



# Special Columns 

This runs a loop to find the max fold changes.
```{r max FC column, eval=FALSE}
#For each MPRA variant, find the fold change of the allele with the largest absolute fold change
# This creates a column full of NAs for the loop to fill
mpra$max_abs_fc <- NA
# This loop calculates the column of max_abs_fc. It takes the two alleles A and B and calculates which one's absolute value is larger. That larger value is the value of the new column (can be positive or negative). 
for(i in 1:nrow(mpra)){
  if(abs(mpra[i,]$A.log2FC)>abs(mpra[i,]$B.log2FC)){
    mpra[i,]$max_abs_fc<-mpra[i,]$A.log2FC
  }else{
    mpra[i,]$max_abs_fc<-mpra[i,]$B.log2FC
  }
}
```

This runs a loop to find the max fold change p values with the Benjamini Hochberg correction.
```{r max BH column, eval=FALSE}
#For each MPRA variant, find the fold change of the allele with the largest absolute fold change
# This creates a column full of NAs for the loop to fill
mpra$max.logPadj_BH<-NA
# This loop calculates the column of max_abs_fc. It takes the two alleles A and B and calculates which one's absolute value is larger. That larger value is the value of the new column (can be positive or negative). 
for(i in 1:nrow(mpra)){
  if(abs(mpra[i,]$A.logPadj_BH)>abs(mpra[i,]$B.logPadj_BH)){
    mpra[i,]$max.logPadj_BH<-mpra[i,]$A.logPadj_BH
  }else{
    mpra[i,]$max.logPadj_BH<-mpra[i,]$B.logPadj_BH
  }
}
```

This runs a loop to find the max fold change p values with the bonferroni correction.
```{r max BF column, eval=FALSE}
#For each MPRA variant, find the fold change of the allele with the largest absolute fold change
# This creates a column full of NAs for the loop to fill
mpra$max.logPadj_BF<-NA
# This loop calculates the column of max_abs_fc. It takes the two alleles A and B and calculates which one's absolute value is larger. That larger value is the value of the new column (can be positive or negative). 
for(i in 1:nrow(mpra)){
  if(abs(mpra[i,]$A.logPadj_BF)>abs(mpra[i,]$B.logPadj_BF)){
    mpra[i,]$max.logPadj_BF<-mpra[i,]$A.logPadj_BF
  }else{
    mpra[i,]$max.logPadj_BF<-mpra[i,]$B.logPadj_BF
  }
}
```


```{r max pics column, eval=FALSE}
#For each MPRA variant, find the pics for all the diseases and make max_pics the maximum of all of those values
mpra.pics <- subset(mpra, select=c(MS_pics,RA_pics,UC_pics,T1D_pics,IBD_pics,Crohns_pics,Psoriasis_pics))

# Make the NAs for pics -1
mpra.pics$MS_pics[is.na(mpra.pics$MS_pics)]<- (-1)
mpra.pics$RA_pics[is.na(mpra.pics$RA_pics)]<- (-1)
mpra.pics$UC_pics[is.na(mpra.pics$UC_pics)]<- (-1)
mpra.pics$IBD_pics[is.na(mpra.pics$IBD_pics)]<- (-1)
mpra.pics$T1D_pics[is.na(mpra.pics$T1D_pics)]<- (-1)
mpra.pics$Crohns_pics[is.na(mpra.pics$Crohns_pics)]<- (-1)
mpra.pics$Psoriasis_pics[is.na(mpra.pics$Psoriasis_pics)]<- (-1)
colnames(mpra.pics)
mpra.pics$win_pics <- colnames(mpra.pics)[apply(mpra.pics,1,which.max)] # Make a column that is called win_pics which will give me the name of the pics column with the best 

mpra.pics$max_pics <- NA # This creates a column full of NAs for the loop to fill

for(i in 1:nrow(mpra.pics)){
  if(mpra.pics[i,]$win_pics=="MS_pics"){
    mpra.pics[i,]$max_pics<-mpra.pics[i,]$MS_pics
  } # if win_pics says MS_pics then the max_pics is MS_pics
  if(mpra.pics[i,]$win_pics=="RA_pics"){
    mpra.pics[i,]$max_pics<-mpra.pics[i,]$RA_pics
  } # if win_pics says RA_pics then the max_pics is RA_pics
  if(mpra.pics[i,]$win_pics=="UC_pics"){
    mpra.pics[i,]$max_pics<-mpra.pics[i,]$UC_pics
  } # if win_pics says UC_pics then the max_pics is UC_pics
  if(mpra.pics[i,]$win_pics=="IBD_pics"){
    mpra.pics[i,]$max_pics<-mpra.pics[i,]$IBD_pics
  } # if win_pics says IBD_pics then the max_pics is IBD_pics
  if(mpra.pics[i,]$win_pics=="Crohns_pics"){
    mpra.pics[i,]$max_pics<-mpra.pics[i,]$Crohns_pics
  } # if win_pics says Crohns_pics then the max_pics is Crohns_pics
  if(mpra.pics[i,]$win_pics=="Psoriasis_pics"){
    mpra.pics[i,]$max_pics<-mpra.pics[i,]$Psoriasis_pics
  } # if win_pics says Psoriasis_pics then the max_pics is Psoriasis_pics
   if(mpra.pics[i,]$win_pics=="T1D_pics"){
    mpra.pics[i,]$max_pics<-mpra.pics[i,]$T1D_pics
  } # if win_pics says T1D_pics then the max_pics is T1D_pics
}

# Make the MPRA pics columns which are NA return to NA
mpra.pics$MS_pics[mpra.pics$MS_pics<0]<- NA
mpra.pics$RA_pics[mpra.pics$RA_pics<0]<- NA
mpra.pics$UC_pics[mpra.pics$UC_pics<0]<- NA
mpra.pics$IBD_pics[mpra.pics$IBD_pics<0]<- NA
mpra.pics$T1D_pics[mpra.pics$T1D_pics<0]<- NA
mpra.pics$Crohns_pics[mpra.pics$Crohns_pics<0]<- NA
mpra.pics$Psoriasis_pics[mpra.pics$Psoriasis_pics<0]<- NA

```

```{r, echo=FALSE, eval=FALSE, echo=FALSE}
if(filter == "none" & mpra_name == "20230518_unstimulated_jurkat_glm"){
mpra$A.log2FC[mpra$A.log2FC==0] <- NA
mpra$B.log2FC[mpra$B.log2FC==0] <- NA
mpra$A.logPadj_BH[mpra$A.logPadj_BH==0] <- NA
mpra$B.logPadj_BH[mpra$B.logPadj_BH==0]<- NA
mpra$A.logPadj_BF[mpra$A.logPadj_BF==0]<- NA
mpra$B.logPadj_BF[mpra$B.logPadj_BF==0]<- NA
}
```

```{r, eval=FALSE}
mpra$max_pics <- mpra.pics$max_pics
```

How many variants in this version of MPRA have a maximum pics value of greater than or equal to 0.5
```{r, eval=FALSE}
nrow(subset(mpra, max_pics>=0.5))
```

# DHS overlap 

Bring in DHS data for CD4 T-cells
```{r, eval=FALSE}
# This is a table I created by subsetting the original dhs.merged.dat to only include CD4 T-cells. This can be done with other cell types when I need to do this analysis for other cell types
dhs.merge.dat <- read.table("/nfs/jray/screens/ALL_MPRAs/Ho_et_al_analysis/Downstream_Analysis/precision_and_recall_analysis/data/dhs.merge.cd4.txt", sep="\t", header=T)
```

This is uploading the dhs position data. 
```{r, eval=FALSE}
#Read in DHS position file
# This is a data frame I made to get rid of a few steps in the creation of dhs.pos
dhs.pos <- read.table("/nfs/jray/screens/ALL_MPRAs/Ho_et_al_analysis/Downstream_Analysis/precision_and_recall_analysis/data/dhs.pos.data", sep="\t", header=T)
#Make into GRanges format
dhs.pos.se<-makeGRangesFromDataFrame(dhs.pos, seqnames = "seqname", start.field = "start", end.field = "end",keep.extra.columns=TRUE) 
```

Give MPRA a strand column
```{r, eval=FALSE}
mpra$strand<-"+"
```

```{r}
#Manually temporarily set these FDRs and adjusted p-values that are NA to -1 for easier TRUE/FALSE testing
mpra$Skew.logFDR[is.na(mpra$Skew.logFDR)]<- (-1)
mpra$max.logPadj_BH[is.na(mpra$max.logPadj_BH)]<- (-1)

#For each variant, assign whether it has no activity (nEnhancer_nSkew), is a pCRE only (Enhancer_nSkew) or emVAR (Enhancer_Skew)
mpra$mpra_sig<-"nEnhancer_nSkew"
for(i in 1:nrow(mpra)){
  if(mpra[i,]$Skew.logFDR>1 & (mpra[i,]$max.logPadj_BH>2 & mpra[i,]$max_abs_fc>1) ){
    mpra[i,]$mpra_sig<-"Enhancer_Skew"
  }else if(mpra[i,]$Skew.logFDR<=1 & (mpra[i,]$max.logPadj_BH>2 & mpra[i,]$max_abs_fc>1) ){
    mpra[i,]$mpra_sig<-"Enhancer_nSkew"
  }
}
#Set those -1 FDRs and p-values back to NA
mpra$Skew.logFDR[mpra$Skew.logFDR<0]<- NA
mpra$max.logPadj_BH[mpra$max.logPadj_BH<0]<- NA
```

original loop
```{r, eval=FALSE, echo=FALSE}

# This is code which gets a single p-value for CD4 cells based on dhs.pos and the MPRA mpra_sig categories
# The loop I create will vary the specifications for variant categories 
#Make into a Granges file
mpra$strand<-"+"
mpra.se<-makeGRangesFromDataFrame(mpra,  seqnames = "chr", start.field = "snp_start", end.field = "snp_end",keep.extra.columns=TRUE)

# This code finds where the genomic positions of the MPRA data and DHS peak data overlap
#Find DHS peaks that overlap with MPRA
overlap_peaks<-data.frame(subsetByOverlaps(dhs.pos.se, mpra.se, type="any"), stringsAsFactors = F)$peak #Find DHS peaks that overlap with MPRA SNPs
overlap_index<-which(dhs.pos$peak%in%overlap_peaks) #Extract row indices of overlapping peaks from DHS file
dhs.pos<-dhs.pos[overlap_index,] #Subset DHS peaks file by index of overlapping peaks
# This removes the mpra.se and dhs.pos.se objects

# Generate peak indices for MPRA SNPs for faster downstream processing
# This creates a new dataframe with seqname, start and end 
dhs.pos<-dhs.merge.dat[,c(1:3)]
# This creates an index column which are just sequentially numbered (1,2,3 etc.)
dhs.pos$index<-seq(1:nrow(dhs.pos))
# This adds the index column to the last data set as well
dhs.merge.dat$index<-seq(1:nrow(dhs.merge.dat))
# This creates a column called peak_index to be filled in by the loop
mpra$peak_index<-NA
# This loop adds a peak_index column to the mpra data
for(i in 1:nrow(mpra)){ #Add in DHS peak index for any peak overlapping MPRA SNP
 mpra[i,]$peak_index<-subset(dhs.pos, seqname==mpra[i,]$chr & start<=mpra[i,]$snp_end & end >=mpra[i,]$snp_end)$index[1]  
 }
# 230 seconds for this loop
# This creates a new dataframe which is the mpra data, but it is subset to only to pCREs and emVars and observations with a peak_index value
pcre_index<-subset(mpra, mpra_sig%in%c("Enhancer_nSkew", "Enhancer_Skew") & !is.na(peak_index))$peak_index #peak indices for MPRA pCRE SNPs only
# This subsets the other observations
non_pcre_index<-subset(mpra, mpra_sig=="nEnhancer_nSkew" & !is.na(peak_index))$peak_index #peak indices for MPRA non-pCRE SNPs

# This code creates the sample dataframe which in this case is just CD4. It is originally made with all the biosample names. 
sample.dat <- data.frame(c("CD4"))
colnames(sample.dat) <- "sample"

# Calculate enrichments of MPRA pCREs in DHS peaks for each cell type

# This created an empty dataframe to be filled by the loop
dat.plot<-data.frame(sample= sample.dat$sample, pcre_fold=0, pcre_p=0, stringsAsFactors = F)
# This loop creates fold enrichment and p-values for the pCREs
for(i in 1:nrow(dat.plot)){
  
  #Find the column in the dhs data that correspond to that cell type
  cell_col<-which(names(dhs.merge.dat)==dat.plot[i,]$sample)
  
  #find which peak_indexes for the peaks in that cell type
  peak_index<-dhs.merge.dat[dhs.merge.dat[,cell_col]==1,]$index

  #Calculate enrichment
  a<-length(intersect(peak_index, pcre_index)) #Number of pCRE in DHS peak
  b<-length(intersect(peak_index, non_pcre_index)) #Number of non-pCRE in DHS peak
  c<-nrow(subset(mpra, mpra_sig%in%c("Enhancer_nSkew", "Enhancer_Skew")))-a #Number of pCRE not in DHS
  d<-nrow(subset(mpra, mpra_sig=="nEnhancer_nSkew"))-b #Number of non-pCRE not in DHS
  dat.plot[i,]$pcre_fold<-(a/(a+c))/(b/(b+d)) #Calcualte fold enrichment
  dat.plot[i,]$pcre_p<-fisher.test(rbind(c(a,b), c(c, d)), alternative="two.sided")$p.value #Calculate p-value
}
dat.plot$pcre_p

```

improved loop
```{r, eval=FALSE, echo=FALSE}
# This is code which gets a single p-value for CD4 cells based on dhs.pos and the MPRA mpra_sig categories
# The loop I create will vary the specifications for variant categories 
#Make into a Granges file
mpra$strand<-"+"
mpra.se<-makeGRangesFromDataFrame(mpra,  seqnames = "chr", start.field = "snp_start", end.field = "snp_end",keep.extra.columns=TRUE)

# This code finds where the genomic positions of the MPRA data and DHS peak data overlap
#Find DHS peaks that overlap with MPRA
overlap_peaks<-data.frame(subsetByOverlaps(dhs.pos.se, mpra.se, type="any"), stringsAsFactors = F)$peak #Find DHS peaks that overlap with MPRA SNPs
overlap_index<-which(dhs.pos$peak%in%overlap_peaks) #Extract row indices of overlapping peaks from DHS file
dhs.pos<-dhs.pos[overlap_index,] #Subset DHS peaks file by index of overlapping peaks
# This removes the mpra.se and dhs.pos.se objects

# Generate peak indices for MPRA SNPs for faster downstream processing
# This creates a new dataframe with seqname, start and end 
dhs.pos<-dhs.merge.dat[,c(1:3)]
# This creates an index column which are just sequentially numbered (1,2,3 etc.)
dhs.pos$index<-seq(1:nrow(dhs.pos))
# This adds the index column to the last data set as well
dhs.merge.dat$index<-seq(1:nrow(dhs.merge.dat))
# This creates a column called peak_index to be filled in by the loop
mpra$peak_index<-NA
# This loop adds a peak_index column to the mpra data
#for(i in 1:nrow(mpra)){ #Add in DHS peak index for any peak overlapping MPRA SNP
#  mpra[i,]$peak_index<-subset(dhs.pos, seqname==mpra[i,]$chr & start<=mpra[i,]$snp_end & end >=mpra[i,]$snp_end)$index[1]  
#  }

# Assuming mpra is your data frame
# Create a function to find the peak index for a single row
find_peak_index <- function(row) {
  dhs_subset <- subset(dhs.pos, seqname == row$chr & start <= row$snp_end & end >= row$snp_end)
  if (nrow(dhs_subset) > 0) {
    return(dhs_subset$index[1])
  } else {
    return(NA)  # No matching DHS peak found
  }
}

# Apply the function to each row of mpra
mpra$peak_index <- sapply(1:nrow(mpra), function(i) find_peak_index(mpra[i, ]))

# This creates a new dataframe which is the mpra data, but it is subset to only to pCREs and emVars and observations with a peak_index value
pcre_index<-subset(mpra, mpra_sig%in%c("Enhancer_nSkew", "Enhancer_Skew") & !is.na(peak_index))$peak_index #peak indices for MPRA pCRE SNPs only
# This subsets the other observations
non_pcre_index<-subset(mpra, mpra_sig=="nEnhancer_nSkew" & !is.na(peak_index))$peak_index #peak indices for MPRA non-pCRE SNPs

# This code creates the sample dataframe which in this case is just CD4. It is originally made with all the biosample names. 
sample.dat <- data.frame(c("CD4"))
colnames(sample.dat) <- "sample"

# Calculate enrichments of MPRA pCREs in DHS peaks for each cell type

# This created an empty dataframe to be filled by the loop
dat.plot<-data.frame(sample= sample.dat$sample, pcre_fold=0, pcre_p=0, stringsAsFactors = F)
# This loop creates fold enrichment and p-values for the pCREs
for(i in 1:nrow(dat.plot)){
  
  #Find the column in the dhs data that correspond to that cell type
  cell_col<-which(names(dhs.merge.dat)==dat.plot[i,]$sample)
  
  #find which peak_indexes for the peaks in that cell type
  peak_index<-dhs.merge.dat[dhs.merge.dat[,cell_col]==1,]$index

  #Calculate enrichment
  a<-length(intersect(peak_index, pcre_index)) #Number of pCRE in DHS peak
  b<-length(intersect(peak_index, non_pcre_index)) #Number of non-pCRE in DHS peak
  c<-nrow(subset(mpra, mpra_sig%in%c("Enhancer_nSkew", "Enhancer_Skew")))-a #Number of pCRE not in DHS
  d<-nrow(subset(mpra, mpra_sig=="nEnhancer_nSkew"))-b #Number of non-pCRE not in DHS
  dat.plot[i,]$pcre_fold<-(a/(a+c))/(b/(b+d)) #Calcualte fold enrichment
  dat.plot[i,]$pcre_p<-fisher.test(rbind(c(a,b), c(c, d)), alternative="two.sided")$p.value #Calculate p-value
}
dat.plot$pcre_p
```


# Loop for CD4 DHS enrichment data 
```{r, eval=FALSE}
#skew_seq <-c(0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 3)
FC_seq <- c(0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 3)
AdjP_seq <- c(0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 3)

precision.skew.dat <- NULL
for(j in AdjP_seq){
  for(k in FC_seq){
mpra2 <- mpra
   
#Manually temporarily set these FDRs and adjusted p-values that are NA to -1 for easier TRUE/FALSE testing
mpra2$Skew.logFDR[is.na(mpra2$Skew.logFDR)]<- (-1)
mpra2$max.logPadj_BH[is.na(mpra2$max.logPadj_BH)]<- (-1)

#For each variant, assign whether it has no activity (nEnhancer_nSkew), is a pCRE only (Enhancer_nSkew) or emVAR (Enhancer_Skew)
mpra2$mpra_sig<-"nEnhancer_nSkew"
for(i in 1:nrow(mpra2)){
  if(mpra2[i,]$Skew.logFDR>1 & (mpra2[i,]$max.logPadj_BH>j & mpra[i,]$max_abs_fc>k) ){
    mpra2[i,]$mpra_sig<-"Enhancer_Skew"
  }else if(mpra2[i,]$Skew.logFDR<=1 & (mpra2[i,]$max.logPadj_BH>j & mpra[i,]$max_abs_fc>k) ){
    mpra2[i,]$mpra_sig<-"Enhancer_nSkew"
  }
}
#Set those -1 FDRs and p-values back to NA
mpra2$Skew.logFDR[mpra2$Skew.logFDR<0]<- NA
mpra2$max.logPadj_BH[mpra2$max.logPadj_BH<0]<- NA
   
#Make into a Granges file
mpra.se<-makeGRangesFromDataFrame(mpra2,  seqnames = "chr", start.field = "snp_start", end.field = "snp_end",keep.extra.columns=TRUE)

# This code finds where the genomic positions of the MPRA data and DHS peak data overlap
#Find DHS peaks that overlap with MPRA
overlap_peaks<-data.frame(subsetByOverlaps(dhs.pos.se, mpra.se, type="any"), stringsAsFactors = F)$peak #Find DHS peaks that overlap with MPRA SNPs
overlap_index<-which(dhs.pos$peak%in%overlap_peaks) #Extract row indices of overlapping peaks from DHS file
dhs.pos<-dhs.pos[overlap_index,] #Subset DHS peaks file by index of overlapping peaks
# This removes the mpra.se and dhs.pos.se objects

# Generate peak indices for MPRA SNPs for faster downstream processing
# This creates a new dataframe with seqname, start and end 
dhs.pos<-dhs.merge.dat[,c(1:3)]
# This creates an index column which are just sequentially numbered (1,2,3 etc.)
dhs.pos$index<-seq(1:nrow(dhs.pos))
# This adds the index column to the last data set as well
dhs.merge.dat$index<-seq(1:nrow(dhs.merge.dat))
# This creates a column called peak_index to be filled in by the loop
mpra2$peak_index<-NA

# Create a function to find the peak index for a single row
find_peak_index <- function(row) {
  dhs_subset <- subset(dhs.pos, seqname == row$chr & start <= row$snp_end & end >= row$snp_end)
  if (nrow(dhs_subset) > 0) {
    return(dhs_subset$index[1])
  } else {
    return(NA)  # No matching DHS peak found
  }
}

# Apply the function to each row of mpra
mpra2$peak_index <- sapply(1:nrow(mpra2), function(i) find_peak_index(mpra2[i, ]))

# This creates a new dataframe which is the mpra data, but it is subset to only to pCREs and emVars and observations with a peak_index value
pcre_index<-subset(mpra2, mpra_sig%in%c("Enhancer_nSkew", "Enhancer_Skew") & !is.na(peak_index))$peak_index #peak indices for MPRA pCRE SNPs only
# This subsets the other observations
non_pcre_index<-subset(mpra2, mpra_sig=="nEnhancer_nSkew" & !is.na(peak_index))$peak_index #peak indices for MPRA non-pCRE SNPs

# This code creates the sample dataframe which in this case is just CD4. It is originally made with all the biosample names. 
sample.dat <- data.frame(c("CD4"))
colnames(sample.dat) <- "sample"

# Calculate enrichments of MPRA pCREs in DHS peaks for each cell type

# This created an empty dataframe to be filled by the loop
dat.plot<-data.frame(sample= sample.dat$sample, pcre_fold=0, pcre_p=0, stringsAsFactors = F)
# This loop creates fold enrichment and p-values for the pCREs
for(i in 1:nrow(dat.plot)){
  
  #Find the column in the dhs data that correspond to that cell type
  cell_col<-which(names(dhs.merge.dat)==dat.plot[i,]$sample)
  
  #find which peak_indexes for the peaks in that cell type
  peak_index<-dhs.merge.dat[dhs.merge.dat[,cell_col]==1,]$index

  #Calculate enrichment
  a<-length(intersect(peak_index, pcre_index)) #Number of pCRE in DHS peak
  b<-length(intersect(peak_index, non_pcre_index)) #Number of non-pCRE in DHS peak
  c<-nrow(subset(mpra2, mpra_sig%in%c("Enhancer_nSkew", "Enhancer_Skew")))-a #Number of pCRE not in DHS
  d<-nrow(subset(mpra2, mpra_sig=="nEnhancer_nSkew"))-b #Number of non-pCRE not in DHS
  dat.plot[i,]$pcre_fold<-(a/(a+c))/(b/(b+d)) #Calcualte fold enrichment
  dat.plot[i,]$pcre_p<-fisher.test(rbind(c(a,b), c(c, d)), alternative="two.sided")$p.value #Calculate p-value
}
pcre_p <- dat.plot$pcre_p
   
   precision.skew.dat <- rbind(precision.skew.dat, data.frame(k, j, pcre_p)) # makes the data frame used for the heat map
  }
}

names(precision.skew.dat) <- c("FC", "pAdj", "pcre_p")
```

# CD4 DHS enrichment heat map

```{r FC Adjp heatmap, eval=FALSE}
FC_AdjP_CD4_DHS_heat_map <- ggplot(data.frame(precision.skew.dat), aes(x = as.character(pAdj), y = as.character(FC), fill = -log10(pcre_p))) +
  geom_tile() + geom_text(aes(label = round(-log10(pcre_p), digits = 2))) + xlab("Log10 Adj FC p-value") + ylab("Log2FC") + 
  ggtitle("CD4 DHS p-value heat map") + scale_fill_gradient(low = "gold", high = "firebrick2") 
FC_AdjP_CD4_DHS_heat_map
# ggsave("FC_AdjP_CD4_DHS_heat_map.png",plot = FC_AdjP_CD4_DHS_heat_map, path = "/nfs/jray/screens/ALL_MPRAs/Ho_et_al_analysis/Downstream_Analysis/precision_and_recall_analysis/plots")
```

![*CD4 DHS enrichment heat map*](/nfs/jray/screens/ALL_MPRAs/Ho_et_al_analysis/Downstream_Analysis/precision_and_recall_analysis/plots/FC_AdjP_CD4_DHS_heat_map.png){width=px}


```{r, eval=FALSE, echo=FALSE}
# This loop is the same as the first, but I am making the loop faster using apply functions


#skew_seq <-c(0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 3)
FC_seq <- c(0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 3)
AdjP_seq <- c(0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 3)

precision.skew.dat <- NULL
for(j in AdjP_seq){
  for(k in FC_seq){
mpra2 <- mpra

#Manually temporarily set these FDRs and adjusted p-values that are NA to -1 for easier TRUE/FALSE testing
mpra2$Skew.logFDR[is.na(mpra2$Skew.logFDR)]<- (-1)
mpra2$max.logPadj_BH[is.na(mpra2$max.logPadj_BH)]<- (-1)

###########################################################################  (NEW APPLY FUNCTION)

#For each variant, assign whether it has no activity (nEnhancer_nSkew), is a pCRE only (Enhancer_nSkew) or emVAR (Enhancer_Skew)
mpra2$mpra_sig <- apply(mpra2, 1, function(row) {
  if (row["Skew.logFDR"] > 1) {
    if (row["A.logPadj_BH"] > j && row["A.log2FC"] > k) {
      return("Enhancer_Skew")
    } else {
      return("nEnhancer_nSkew")
    }
  } else if (row["A.logPadj_BH"] > j && row["A.log2FC"] > k) {
    return("Enhancer_nSkew")
  }
  return("nEnhancer_nSkew")
})

###########################################################################

#Set those -1 FDRs and p-values back to NA
mpra2$Skew.logFDR[mpra2$Skew.logFDR<0]<- NA
mpra2$max.logPadj_BH[mpra2$max.logPadj_BH<0]<- NA
   
#Make into a Granges file
mpra.se<-makeGRangesFromDataFrame(mpra2,  seqnames = "chr", start.field = "snp_start", end.field = "snp_end",keep.extra.columns=TRUE)

# This code finds where the genomic positions of the MPRA data and DHS peak data overlap
#Find DHS peaks that overlap with MPRA
overlap_peaks<-data.frame(subsetByOverlaps(dhs.pos.se, mpra.se, type="any"), stringsAsFactors = F)$peak #Find DHS peaks that overlap with MPRA SNPs
overlap_index<-which(dhs.pos$peak%in%overlap_peaks) #Extract row indices of overlapping peaks from DHS file
dhs.pos<-dhs.pos[overlap_index,] #Subset DHS peaks file by index of overlapping peaks
# This removes the mpra.se and dhs.pos.se objects

# Generate peak indices for MPRA SNPs for faster downstream processing
# This creates a new dataframe with seqname, start and end 
dhs.pos<-dhs.merge.dat[,c(1:3)]
# This creates an index column which are just sequentially numbered (1,2,3 etc.)
dhs.pos$index<-seq(1:nrow(dhs.pos))
# This adds the index column to the last data set as well
dhs.merge.dat$index<-seq(1:nrow(dhs.merge.dat))
# This creates a column called peak_index to be filled in by the loop
mpra2$peak_index<-NA

###########################################################################  (NEW APPLY FUNCTION)

# This loop adds a peak_index column to the mpra data 
mpra2$peak_index <- sapply(1:nrow(mpra2), function(i) {
  dhs_subset <- subset(dhs.pos, seqname == mpra2[i, "chr"] & start <= mpra2[i, "snp_end"] & end >= mpra2[i, "snp_end"])
  if (nrow(dhs_subset) > 0) {
    return(dhs_subset$index[1])
  } else {
    return(NA)  # No matching DHS peak found
  }
})

###########################################################################

# This creates a new dataframe which is the mpra data, but it is subset to only to pCREs and emVars and observations with a peak_index value
pcre_index<-subset(mpra2, mpra_sig%in%c("Enhancer_nSkew", "Enhancer_Skew") & !is.na(peak_index))$peak_index #peak indices for MPRA pCRE SNPs only
# This subsets the other observations
non_pcre_index<-subset(mpra2, mpra_sig=="nEnhancer_nSkew" & !is.na(peak_index))$peak_index #peak indices for MPRA non-pCRE SNPs

# This code creates the sample dataframe which in this case is just CD4. It is originally made with all the biosample names. 
sample.dat <- data.frame(c("CD4"))
colnames(sample.dat) <- "sample"

# Calculate enrichments of MPRA pCREs in DHS peaks for each cell type

# This created an empty dataframe to be filled by the loop
dat.plot<-data.frame(sample= sample.dat$sample, pcre_fold=0, pcre_p=0, stringsAsFactors = F)
# This loop creates fold enrichment and p-values for the pCREs

########################################################################### (NEW APPLY FUNCTION)

# Find the column indices for the cell types in dhs.merge.dat 
cell_cols <- sapply(dat.plot$sample, function(sample) which(names(dhs.merge.dat) == sample))

# Find peak indexes for the peaks in each cell type
peak_indexes <- lapply(cell_cols, function(cell_col) dhs.merge.dat[dhs.merge.dat[, cell_col] == 1, "index"])

# Calculate enrichment for each row
dat.plot$pcre_fold <- sapply(1:nrow(dat.plot), function(i) {
  a <- length(intersect(peak_indexes[[i]], pcre_index))
  b <- length(intersect(peak_indexes[[i]], non_pcre_index))
  c <- sum(mpra2$mpra_sig %in% c("Enhancer_nSkew", "Enhancer_Skew")) - a
  d <- sum(mpra2$mpra_sig == "nEnhancer_nSkew") - b
  (a / (a + c)) / (b / (b + d))
})

# Calculate p-values for each row
dat.plot$pcre_p <- sapply(1:nrow(dat.plot), function(i) {
  obs <- matrix(c(length(intersect(peak_indexes[[i]], pcre_index)), length(intersect(peak_indexes[[i]], non_pcre_index)), 
                  sum(mpra2$mpra_sig %in% c("Enhancer_nSkew", "Enhancer_Skew")) - length(intersect(peak_indexes[[i]], pcre_index)), 
                  sum(mpra2$mpra_sig == "nEnhancer_nSkew") - length(intersect(peak_indexes[[i]], non_pcre_index))), nrow = 2)
  fisher.test(obs, alternative = "two.sided")$p.value
})

###########################################################################

pcre_p <- dat.plot$pcre_p
   
   precision.skew.dat <- rbind(precision.skew.dat, data.frame(k, j, pcre_p)) # makes the data frame used for the heat map
  }
}

names(precision.skew.dat) <- c("FC", "pAdj", "pcre_p")


FC_AdjP_CD4_DHS_heat_map3 <- ggplot(data.frame(precision.skew.dat), aes(x = as.character(pAdj), y = as.character(FC), fill = -log10(pcre_p))) +
  geom_tile() + geom_text(aes(label = round(-log10(pcre_p), digits = 2))) + xlab("Log10 Adj FC p-value") + ylab("Log2FC") + 
  ggtitle("CD4 DHS enrichment heatmap") + scale_fill_gradient(low = "gold", high = "firebrick2") 
FC_AdjP_CD4_DHS_heat_map3

mpra2$Skew
```



Heat maps which match the original precision and recall analysis.
```{r, eval=FALSE}
# Skew FDR vs. Skew heat map  
skew_seq <-c(0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 3)
FDR_seq <-c(0.001, 0.01, 0.05, 0.1, 0.15, 0.2, 0.25, 0.5, 0.75, 1)

precision.skew.dat.dhs <- NULL
for(j in skew_seq){
  for(k in FDR_seq){
mpra2 <- mpra

mpra2$SkewFDR<- 10^-mpra2$Skew.logFDR # undo the negative log transformation of the Skew log p-values and create the column SkewFDR
mpra2$Skew<- 2^mpra2$LogSkew # undo the log transformation of logSkew to create a column called skew

#Manually temporarily set these FDRs and adjusted p-values that are NA to -1 for easier TRUE/FALSE testing
mpra2$SkewFDR[is.na(mpra2$SkewFDR)]<- (-1)
mpra2$Skew[is.na(mpra2$Skew)]<- (-1)

###########################################################################  (NEW APPLY FUNCTION)

#For each variant, assign whether it has no activity (nEnhancer_nSkew), is a pCRE only (Enhancer_nSkew) or emVAR (Enhancer_Skew)
# mpra2$mpra_sig <- apply(mpra2, 1, function(row) {
#  if (row["Skew.logFDR"] > 1) {
#    if (row["Skew"] > j && row["SkewFDR"] > k) {
#      return("Enhancer_Skew")
#    } else {
#      return("nEnhancer_nSkew")
#    }
#  } else if (row["Skew"] > j && row["SkewFDR"] > k) {
#    return("Enhancer_nSkew")
#  }
#  return("nEnhancer_nSkew")
# })

#Manually temporarily set these FDRs and adjusted p-values that are NA to -1 for easier TRUE/FALSE testing
mpra2$SkewFDR[is.na(mpra2$SkewFDR)]<- (-1)
mpra2$Skew[is.na(mpra2$Skew)]<- (-1)

#For each variant, assign whether it has no activity (nEnhancer_nSkew), is a pCRE only (Enhancer_nSkew) or emVAR (Enhancer_Skew)
mpra2$mpra_sig<-"nEnhancer_nSkew"
for(i in 1:nrow(mpra2)){
  if(mpra2[i,]$Skew.logFDR>1 & (mpra2[i,]$Skew>j & mpra2[i,]$SkewFDR>k) ){
    mpra2[i,]$mpra_sig<-"Enhancer_Skew"
  }else if(mpra2[i,]$Skew.logFDR<=1 & (mpra2[i,]$Skew>j & mpra2[i,]$SkewFDR>k) ){
    mpra2[i,]$mpra_sig<-"Enhancer_nSkew"
  }
}
#Set those -1 FDRs and p-values back to NA
mpra2$SkewFDR[mpra2$SkewFDR<0]<- NA
mpra2$Skew[mpra2$Skew<0]<- NA

###########################################################################

#Set those -1 FDRs and p-values back to NA
mpra2$SkewFDR[mpra2$SkewFDR<0]<- NA
mpra2$Skew[mpra2$Skew<0]<- NA
   
#Make into a Granges file
mpra.se<-makeGRangesFromDataFrame(mpra2,  seqnames = "chr", start.field = "snp_start", end.field = "snp_end",keep.extra.columns=TRUE)

# This code finds where the genomic positions of the MPRA data and DHS peak data overlap
#Find DHS peaks that overlap with MPRA
overlap_peaks<-data.frame(subsetByOverlaps(dhs.pos.se, mpra.se, type="any"), stringsAsFactors = F)$peak #Find DHS peaks that overlap with MPRA SNPs
overlap_index<-which(dhs.pos$peak%in%overlap_peaks) #Extract row indices of overlapping peaks from DHS file
dhs.pos<-dhs.pos[overlap_index,] #Subset DHS peaks file by index of overlapping peaks
# This removes the mpra.se and dhs.pos.se objects

# Generate peak indices for MPRA SNPs for faster downstream processing
# This creates a new dataframe with seqname, start and end 
dhs.pos<-dhs.merge.dat[,c(1:3)]
# This creates an index column which are just sequentially numbered (1,2,3 etc.)
dhs.pos$index<-seq(1:nrow(dhs.pos))
# This adds the index column to the last data set as well
dhs.merge.dat$index<-seq(1:nrow(dhs.merge.dat))
# This creates a column called peak_index to be filled in by the loop
mpra2$peak_index<-NA

###########################################################################  (NEW APPLY FUNCTION)

for(i in 1:nrow(mpra2)){ #Add in DHS peak index for any peak overlapping MPRA SNP
  mpra2[i,]$peak_index<-subset(dhs.pos, seqname==mpra2[i,]$chr & start<=mpra2[i,]$snp_end & end >=mpra2[i,]$snp_end)$index[1]  
}

###########################################################################

# This creates a new dataframe which is the mpra data, but it is subset to only to pCREs and emVars and observations with a peak_index value
pcre_index<-subset(mpra2, mpra_sig%in%c("Enhancer_nSkew", "Enhancer_Skew") & !is.na(peak_index))$peak_index #peak indices for MPRA pCRE SNPs only
# This subsets the other observations
non_pcre_index<-subset(mpra2, mpra_sig=="nEnhancer_nSkew" & !is.na(peak_index))$peak_index #peak indices for MPRA non-pCRE SNPs

# This code creates the sample dataframe which in this case is just CD4. It is originally made with all the biosample names. 
sample.dat <- data.frame(c("CD4"))
colnames(sample.dat) <- "sample"

# Calculate enrichments of MPRA pCREs in DHS peaks for each cell type

# This created an empty dataframe to be filled by the loop
dat.plot<-data.frame(sample= sample.dat$sample, pcre_fold=0, pcre_p=0, stringsAsFactors = F)
# This loop creates fold enrichment and p-values for the pCREs

########################################################################### (NEW APPLY FUNCTION)

for(i in 1:nrow(dat.plot)){
  
  #Find the column in the dhs data that correspond to that cell type
  cell_col<-which(names(dhs.merge.dat)==dat.plot[i,]$sample)
  
  #find which peak_indexes for the peaks in that cell type
  peak_index<-dhs.merge.dat[dhs.merge.dat[,cell_col]==1,]$index

  #Calculate enrichment
  a<-length(intersect(peak_index, pcre_index)) #Number of pCRE in DHS peak
  b<-length(intersect(peak_index, non_pcre_index)) #Number of non-pCRE in DHS peak
  c<-nrow(subset(mpra2, mpra_sig%in%c("Enhancer_nSkew", "Enhancer_Skew")))-a #Number of pCRE not in DHS
  d<-nrow(subset(mpra2, mpra_sig=="nEnhancer_nSkew"))-b #Number of non-pCRE not in DHS
  dat.plot[i,]$pcre_fold<-(a/(a+c))/(b/(b+d)) #Calcualte fold enrichment
  dat.plot[i,]$pcre_p<-fisher.test(rbind(c(a,b), c(c, d)), alternative="two.sided")$p.value #Calculate p-value
}

###########################################################################

pcre_p <- dat.plot$pcre_p
   
   precision.skew.dat.dhs <- rbind(precision.skew.dat.dhs, data.frame(k, j, pcre_p)) # makes the data frame used for the heat map
  }
}
names(precision.skew.dat.dhs) <- c("FDR", "Skew", "pcre_p")


Skew_FDR_CD4_DHS_heat_map <- ggplot(data.frame(precision.skew.dat.dhs), aes(x = as.character(FDR), y = as.character(Skew), fill = -log10(pcre_p))) +
  geom_tile() + geom_text(aes(label = round(-log10(pcre_p), digits = 2))) + xlab("Skew FDR") + ylab("Skew") + 
  ggtitle("CD4 DHS enrichment heatmap") + scale_fill_gradient(low = "gold", high = "firebrick2") 
Skew_FDR_CD4_DHS_heat_map

##############################################################################################
#############
#############
#############
##############################################################################################

# Skew FDR vs. FC heat map  
FC_seq <- c(0, 0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 3, 4, 5, 6, 7, 8)
FDR_seq <-c(0.001, 0.01, 0.05, 0.1, 0.15, 0.2, 0.25, 0.5, 0.75, 1)

precision.FC.dat.dhs <- NULL
for(j in FC_seq){
  for(k in FDR_seq){
mpra2 <- mpra

mpra2$SkewFDR<- 10^-mpra2$Skew.logFDR # undo the negative log transformation of the Skew log p-values and create the column SkewFDR
mpra2$Skew<- 2^mpra2$LogSkew # undo the log transformation of logSkew to create a column called skew
mpra2$FC<- 2^mpra2$max_abs_fc # undo the log transformation of log 2 fold change to create a column called FC

#Manually temporarily set these FDRs and adjusted p-values that are NA to -1 for easier TRUE/FALSE testing
mpra2$SkewFDR[is.na(mpra2$SkewFDR)]<- (-1)
mpra2$FC[is.na(mpra2$FC)]<- (-1)

###########################################################################  (NEW APPLY FUNCTION)

#For each variant, assign whether it has no activity (nEnhancer_nSkew), is a pCRE only (Enhancer_nSkew) or emVAR (Enhancer_Skew)
# mpra2$mpra_sig <- apply(mpra2, 1, function(row) {
#  if (row["Skew.logFDR"] > 1) {
#    if (row["FC"] > j && row["SkewFDR"] > k) {
#      return("Enhancer_Skew")
#    } else {
#      return("nEnhancer_nSkew")
#    }
#  } else if (row["FC"] > j && row["SkewFDR"] > k) {
#    return("Enhancer_nSkew")
#  }
#  return("nEnhancer_nSkew")
# })

#Manually temporarily set these FDRs and adjusted p-values that are NA to -1 for easier TRUE/FALSE testing
mpra2$SkewFDR[is.na(mpra2$SkewFDR)]<- (-1)
mpra2$FC[is.na(mpra2$FC)]<- (-1)

#For each variant, assign whether it has no activity (nEnhancer_nSkew), is a pCRE only (Enhancer_nSkew) or emVAR (Enhancer_Skew)
mpra2$mpra_sig<-"nEnhancer_nSkew"
for(i in 1:nrow(mpra2)){
  if(mpra2[i,]$Skew.logFDR>1 & (mpra2[i,]$FC>j & mpra2[i,]$SkewFDR>k) ){
    mpra2[i,]$mpra_sig<-"Enhancer_Skew"
  }else if(mpra2[i,]$Skew.logFDR<=1 & (mpra2[i,]$FC>j & mpra2[i,]$SkewFDR>k) ){
    mpra2[i,]$mpra_sig<-"Enhancer_nSkew"
  }
}
#Set those -1 FDRs and p-values back to NA
mpra2$SkewFDR[mpra2$SkewFDR<0]<- NA
mpra2$FC[mpra2$FC<0]<- NA




###########################################################################

#Set those -1 FDRs and p-values back to NA
mpra2$SkewFDR[mpra2$SkewFDR<0]<- NA
mpra2$FC[mpra2$FC<0]<- NA
   
#Make into a Granges file
mpra.se<-makeGRangesFromDataFrame(mpra2,  seqnames = "chr", start.field = "snp_start", end.field = "snp_end",keep.extra.columns=TRUE)

# This code finds where the genomic positions of the MPRA data and DHS peak data overlap
#Find DHS peaks that overlap with MPRA
overlap_peaks<-data.frame(subsetByOverlaps(dhs.pos.se, mpra.se, type="any"), stringsAsFactors = F)$peak #Find DHS peaks that overlap with MPRA SNPs
overlap_index<-which(dhs.pos$peak%in%overlap_peaks) #Extract row indices of overlapping peaks from DHS file
dhs.pos<-dhs.pos[overlap_index,] #Subset DHS peaks file by index of overlapping peaks
# This removes the mpra.se and dhs.pos.se objects

# Generate peak indices for MPRA SNPs for faster downstream processing
# This creates a new dataframe with seqname, start and end 
dhs.pos<-dhs.merge.dat[,c(1:3)]
# This creates an index column which are just sequentially numbered (1,2,3 etc.)
dhs.pos$index<-seq(1:nrow(dhs.pos))
# This adds the index column to the last data set as well
dhs.merge.dat$index<-seq(1:nrow(dhs.merge.dat))
# This creates a column called peak_index to be filled in by the loop
mpra2$peak_index<-NA

###########################################################################  (NEW APPLY FUNCTION)

for(i in 1:nrow(mpra2)){ #Add in DHS peak index for any peak overlapping MPRA SNP
  mpra2[i,]$peak_index<-subset(dhs.pos, seqname==mpra2[i,]$chr & start<=mpra2[i,]$snp_end & end >=mpra2[i,]$snp_end)$index[1]  
}

###########################################################################

# This creates a new dataframe which is the mpra data, but it is subset to only to pCREs and emVars and observations with a peak_index value
pcre_index<-subset(mpra2, mpra_sig%in%c("Enhancer_nSkew", "Enhancer_Skew") & !is.na(peak_index))$peak_index #peak indices for MPRA pCRE SNPs only
# This subsets the other observations
non_pcre_index<-subset(mpra2, mpra_sig=="nEnhancer_nSkew" & !is.na(peak_index))$peak_index #peak indices for MPRA non-pCRE SNPs

# This code creates the sample dataframe which in this case is just CD4. It is originally made with all the biosample names. 
sample.dat <- data.frame(c("CD4"))
colnames(sample.dat) <- "sample"

# Calculate enrichments of MPRA pCREs in DHS peaks for each cell type

# This created an empty dataframe to be filled by the loop
dat.plot<-data.frame(sample= sample.dat$sample, pcre_fold=0, pcre_p=0, stringsAsFactors = F)
# This loop creates fold enrichment and p-values for the pCREs

########################################################################### (NEW APPLY FUNCTION)

for(i in 1:nrow(dat.plot)){
  
  #Find the column in the dhs data that correspond to that cell type
  cell_col<-which(names(dhs.merge.dat)==dat.plot[i,]$sample)
  
  #find which peak_indexes for the peaks in that cell type
  peak_index<-dhs.merge.dat[dhs.merge.dat[,cell_col]==1,]$index

  #Calculate enrichment
  a<-length(intersect(peak_index, pcre_index)) #Number of pCRE in DHS peak
  b<-length(intersect(peak_index, non_pcre_index)) #Number of non-pCRE in DHS peak
  c<-nrow(subset(mpra2, mpra_sig%in%c("Enhancer_nSkew", "Enhancer_Skew")))-a #Number of pCRE not in DHS
  d<-nrow(subset(mpra2, mpra_sig=="nEnhancer_nSkew"))-b #Number of non-pCRE not in DHS
  dat.plot[i,]$pcre_fold<-(a/(a+c))/(b/(b+d)) #Calcualte fold enrichment
  dat.plot[i,]$pcre_p<-fisher.test(rbind(c(a,b), c(c, d)), alternative="two.sided")$p.value #Calculate p-value
}

###########################################################################

pcre_p <- dat.plot$pcre_p
   
   precision.FC.dat.dhs <- rbind(precision.FC.dat.dhs, data.frame(k, j, pcre_p)) # makes the data frame used for the heat map
  }
}
names(precision.FC.dat.dhs) <- c("FDR", "FC", "pcre_p")

FC_FDR_CD4_DHS_heat_map <- ggplot(data.frame(precision.FC.dat.dhs), aes(x = as.character(FDR), y = as.character(FC), fill = -log10(pcre_p))) +
  geom_tile() + geom_text(aes(label = round(-log10(pcre_p), digits = 2))) + xlab("Skew FDR") + ylab("FC") + 
  ggtitle("CD4 DHS enrichment FC heatmap") + scale_fill_gradient(low = "gold", high = "firebrick2") 
FC_FDR_CD4_DHS_heat_map


#######################################################################
############
############
############
#######################################################################

# Skew FDR vs. BH heat map  
BH_seq <-c(0.001, 0.01, 0.05, 0.1, 0.15, 0.2, 0.25, 0.5, 0.75, 1)
FDR_seq <-c(0.001, 0.01, 0.05, 0.1, 0.15, 0.2, 0.25, 0.5, 0.75, 1)

precision.BH.dat.dhs <- NULL
for(j in BH_seq){
  for(k in FDR_seq){
mpra2 <- mpra

mpra2$SkewFDR<- 10^-mpra2$Skew.logFDR # undo the negative log transformation of the Skew log p-values and create the column SkewFDR
mpra2$Skew<- 2^mpra2$LogSkew # undo the log transformation of logSkew to create a column called skew
mpra2$BH<- 10^-mpra2$max.logPadj_BH # undo the log transformation of log 2 fold change to create a column called BH

#Manually temporarily set these FDRs and adjusted p-values that are NA to -1 for easier TRUE/FALSE testing
mpra2$SkewFDR[is.na(mpra2$SkewFDR)]<- (-1)
mpra2$BH[is.na(mpra2$BH)]<- (-1)

###########################################################################  (NEW APPLY FUNCTION)

#For each variant, assign whether it has no activity (nEnhancer_nSkew), is a pCRE only (Enhancer_nSkew) or emVAR (Enhancer_Skew)
#mpra2$mpra_sig <- apply(mpra2, 1, function(row) {
#  if (row["Skew.logFDR"] > 1) {
#    if (row["BH"] > j && row["SkewFDR"] > k) {
#      return("Enhancer_Skew")
#    } else {
#      return("nEnhancer_nSkew")
#    }
#  } else if (row["BH"] > j && row["SkewFDR"] > k) {
#    return("Enhancer_nSkew")
#  }
#  return("nEnhancer_nSkew")
# })

#Manually temporarily set these FDRs and adjusted p-values that are NA to -1 for easier TRUE/FALSE testing
mpra2$SkewFDR[is.na(mpra2$SkewFDR)]<- (-1)
mpra2$BH[is.na(mpra2$BH)]<- (-1)

#For each variant, assign whether it has no activity (nEnhancer_nSkew), is a pCRE only (Enhancer_nSkew) or emVAR (Enhancer_Skew)
mpra2$mpra_sig<-"nEnhancer_nSkew"
for(i in 1:nrow(mpra2)){
  if(mpra2[i,]$Skew.logFDR>1 & (mpra2[i,]$BH>j & mpra2[i,]$SkewFDR>k) ){
    mpra2[i,]$mpra_sig<-"Enhancer_Skew"
  }else if(mpra2[i,]$Skew.logFDR<=1 & (mpra2[i,]$BH>j & mpra2[i,]$SkewFDR>k) ){
    mpra2[i,]$mpra_sig<-"Enhancer_nSkew"
  }
}
#Set those -1 FDRs and p-values back to NA
mpra2$SkewFDR[mpra2$SkewFDR<0]<- NA
mpra2$BH[mpra2$BH<0]<- NA



###########################################################################

#Set those -1 FDRs and p-values back to NA
mpra2$SkewFDR[mpra2$SkewFDR<0]<- NA
mpra2$BH[mpra2$BH<0]<- NA
   
#Make into a Granges file
mpra.se<-makeGRangesFromDataFrame(mpra2,  seqnames = "chr", start.field = "snp_start", end.field = "snp_end",keep.extra.columns=TRUE)

# This code finds where the genomic positions of the MPRA data and DHS peak data overlap
#Find DHS peaks that overlap with MPRA
overlap_peaks<-data.frame(subsetByOverlaps(dhs.pos.se, mpra.se, type="any"), stringsAsFactors = F)$peak #Find DHS peaks that overlap with MPRA SNPs
overlap_index<-which(dhs.pos$peak%in%overlap_peaks) #Extract row indices of overlapping peaks from DHS file
dhs.pos<-dhs.pos[overlap_index,] #Subset DHS peaks file by index of overlapping peaks
# This removes the mpra.se and dhs.pos.se objects

# Generate peak indices for MPRA SNPs for faster downstream processing
# This creates a new dataframe with seqname, start and end 
dhs.pos<-dhs.merge.dat[,c(1:3)]
# This creates an index column which are just sequentially numbered (1,2,3 etc.)
dhs.pos$index<-seq(1:nrow(dhs.pos))
# This adds the index column to the last data set as well
dhs.merge.dat$index<-seq(1:nrow(dhs.merge.dat))
# This creates a column called peak_index to be filled in by the loop
mpra2$peak_index<-NA

###########################################################################  (NEW APPLY FUNCTION)

# This loop adds a peak_index column to the mpra data 
for(i in 1:nrow(mpra2)){ #Add in DHS peak index for any peak overlapping MPRA SNP
  mpra2[i,]$peak_index<-subset(dhs.pos, seqname==mpra2[i,]$chr & start<=mpra2[i,]$snp_end & end >=mpra2[i,]$snp_end)$index[1]  
}

###########################################################################

# This creates a new dataframe which is the mpra data, but it is subset to only to pCREs and emVars and observations with a peak_index value
pcre_index<-subset(mpra2, mpra_sig%in%c("Enhancer_nSkew", "Enhancer_Skew") & !is.na(peak_index))$peak_index #peak indices for MPRA pCRE SNPs only
# This subsets the other observations
non_pcre_index<-subset(mpra2, mpra_sig=="nEnhancer_nSkew" & !is.na(peak_index))$peak_index #peak indices for MPRA non-pCRE SNPs

# This code creates the sample dataframe which in this case is just CD4. It is originally made with all the biosample names. 
sample.dat <- data.frame(c("CD4"))
colnames(sample.dat) <- "sample"

# Calculate enrichments of MPRA pCREs in DHS peaks for each cell type

# This created an empty dataframe to be filled by the loop
dat.plot<-data.frame(sample= sample.dat$sample, pcre_fold=0, pcre_p=0, stringsAsFactors = F)
# This loop creates fold enrichment and p-values for the pCREs

########################################################################### (NEW APPLY FUNCTION)

for(i in 1:nrow(dat.plot)){
  
  #Find the column in the dhs data that correspond to that cell type
  cell_col<-which(names(dhs.merge.dat)==dat.plot[i,]$sample)
  
  #find which peak_indexes for the peaks in that cell type
  peak_index<-dhs.merge.dat[dhs.merge.dat[,cell_col]==1,]$index

  #Calculate enrichment
  a<-length(intersect(peak_index, pcre_index)) #Number of pCRE in DHS peak
  b<-length(intersect(peak_index, non_pcre_index)) #Number of non-pCRE in DHS peak
  c<-nrow(subset(mpra2, mpra_sig%in%c("Enhancer_nSkew", "Enhancer_Skew")))-a #Number of pCRE not in DHS
  d<-nrow(subset(mpra2, mpra_sig=="nEnhancer_nSkew"))-b #Number of non-pCRE not in DHS
  dat.plot[i,]$pcre_fold<-(a/(a+c))/(b/(b+d)) #Calcualte fold enrichment
  dat.plot[i,]$pcre_p<-fisher.test(rbind(c(a,b), c(c, d)), alternative="two.sided")$p.value #Calculate p-value
}

###########################################################################

pcre_p <- dat.plot$pcre_p
   
   precision.BH.dat.dhs <- rbind(precision.BH.dat.dhs, data.frame(k, j, pcre_p)) # makes the data frame used for the heat map
  }
}
names(precision.BH.dat.dhs) <- c("FDR", "BH", "pcre_p")

BH_FDR_CD4_DHS_heat_map <- ggplot(data.frame(precision.BH.dat.dhs), aes(x = as.character(FDR), y = as.character(BH), fill = -log10(pcre_p))) +
  geom_tile() + geom_text(aes(label = round(-log10(pcre_p), digits = 2))) + xlab("Skew FDR") + ylab("BH") + 
  ggtitle("CD4 DHS enrichment BH heatmap") + scale_fill_gradient(low = "gold", high = "firebrick2") 
BH_FDR_CD4_DHS_heat_map

#######################################################################
############
############
############
#######################################################################

# Skew FDR vs. BF heat map  
BF_seq <-c(0.001, 0.01, 0.05, 0.1, 0.15, 0.2, 0.25, 0.5, 0.75, 1)
FDR_seq <-c(0.001, 0.01, 0.05, 0.1, 0.15, 0.2, 0.25, 0.5, 0.75, 1)

precision.BF.dat.dhs <- NULL
for(j in BF_seq){
  for(k in FDR_seq){
mpra2 <- mpra

mpra2$SkewFDR<- 10^-mpra2$Skew.logFDR # undo the negative log transformation of the Skew log p-values and create the column SkewFDR
mpra2$Skew<- 2^mpra2$LogSkew # undo the log transformation of logSkew to create a column called skew
mpra2$BF<- 10^-mpra2$max.logPadj_BF # undo the log transformation of log 2 fold change to create a column called BF

#Manually temporarily set these FDRs and adjusted p-values that are NA to -1 for easier TRUE/FALSE testing
mpra2$SkewFDR[is.na(mpra2$SkewFDR)]<- (-1)
mpra2$BF[is.na(mpra2$BF)]<- (-1)

###########################################################################  (NEW APPLY FUNCTION)

#For each variant, assign whether it has no activity (nEnhancer_nSkew), is a pCRE only (Enhancer_nSkew) or emVAR (Enhancer_Skew)
#mpra2$mpra_sig <- apply(mpra2, 1, function(row) {
#  if (row["Skew.logFDR"] > 1) {
#    if (row["BF"] > j && row["SkewFDR"] > k) {
#      return("Enhancer_Skew")
#    } else {
#      return("nEnhancer_nSkew")
#    }
#  } else if (row["BF"] > j && row["SkewFDR"] > k) {
#    return("Enhancer_nSkew")
#  }
#  return("nEnhancer_nSkew")
# })

#Manually temporarily set these FDRs and adjusted p-values that are NA to -1 for easier TRUE/FALSE testing
mpra2$SkewFDR[is.na(mpra2$SkewFDR)]<- (-1)
mpra2$BF[is.na(mpra2$BF)]<- (-1)

#For each variant, assign whether it has no activity (nEnhancer_nSkew), is a pCRE only (Enhancer_nSkew) or emVAR (Enhancer_Skew)
mpra2$mpra_sig<-"nEnhancer_nSkew"
for(i in 1:nrow(mpra2)){
  if(mpra2[i,]$Skew.logFDR>1 & (mpra2[i,]$BF>j & mpra2[i,]$SkewFDR>k) ){
    mpra2[i,]$mpra_sig<-"Enhancer_Skew"
  }else if(mpra2[i,]$Skew.logFDR<=1 & (mpra2[i,]$BF>j & mpra2[i,]$SkewFDR>k) ){
    mpra2[i,]$mpra_sig<-"Enhancer_nSkew"
  }
}
#Set those -1 FDRs and p-values back to NA
mpra2$SkewFDR[mpra2$SkewFDR<0]<- NA
mpra2$BF[mpra2$BF<0]<- NA




###########################################################################

#Set those -1 FDRs and p-values back to NA
mpra2$SkewFDR[mpra2$SkewFDR<0]<- NA
mpra2$BF[mpra2$BF<0]<- NA
   
#Make into a Granges file
mpra.se<-makeGRangesFromDataFrame(mpra2,  seqnames = "chr", start.field = "snp_start", end.field = "snp_end",keep.extra.columns=TRUE)

# This code finds where the genomic positions of the MPRA data and DHS peak data overlap
#Find DHS peaks that overlap with MPRA
overlap_peaks<-data.frame(subsetByOverlaps(dhs.pos.se, mpra.se, type="any"), stringsAsFactors = F)$peak #Find DHS peaks that overlap with MPRA SNPs
overlap_index<-which(dhs.pos$peak%in%overlap_peaks) #Extract row indices of overlapping peaks from DHS file
dhs.pos<-dhs.pos[overlap_index,] #Subset DHS peaks file by index of overlapping peaks
# This removes the mpra.se and dhs.pos.se objects

# Generate peak indices for MPRA SNPs for faster downstream processing
# This creates a new dataframe with seqname, start and end 
dhs.pos<-dhs.merge.dat[,c(1:3)]
# This creates an index column which are just sequentially numbered (1,2,3 etc.)
dhs.pos$index<-seq(1:nrow(dhs.pos))
# This adds the index column to the last data set as well
dhs.merge.dat$index<-seq(1:nrow(dhs.merge.dat))
# This creates a column called peak_index to be filled in by the loop
mpra2$peak_index<-NA

###########################################################################  (NEW APPLY FUNCTION)

# This loop adds a peak_index column to the mpra data 
for(i in 1:nrow(mpra2)){ #Add in DHS peak index for any peak overlapping MPRA SNP
  mpra2[i,]$peak_index<-subset(dhs.pos, seqname==mpra2[i,]$chr & start<=mpra2[i,]$snp_end & end >=mpra2[i,]$snp_end)$index[1]  
}

###########################################################################

# This creates a new dataframe which is the mpra data, but it is subset to only to pCREs and emVars and observations with a peak_index value
pcre_index<-subset(mpra2, mpra_sig%in%c("Enhancer_nSkew", "Enhancer_Skew") & !is.na(peak_index))$peak_index #peak indices for MPRA pCRE SNPs only
# This subsets the other observations
non_pcre_index<-subset(mpra2, mpra_sig=="nEnhancer_nSkew" & !is.na(peak_index))$peak_index #peak indices for MPRA non-pCRE SNPs

# This code creates the sample dataframe which in this case is just CD4. It is originally made with all the biosample names. 
sample.dat <- data.frame(c("CD4"))
colnames(sample.dat) <- "sample"

# Calculate enrichments of MPRA pCREs in DHS peaks for each cell type

# This created an empty dataframe to be filled by the loop
dat.plot<-data.frame(sample= sample.dat$sample, pcre_fold=0, pcre_p=0, stringsAsFactors = F)
# This loop creates fold enrichment and p-values for the pCREs

########################################################################### (NEW APPLY FUNCTION)

for(i in 1:nrow(dat.plot)){
  
  #Find the column in the dhs data that correspond to that cell type
  cell_col<-which(names(dhs.merge.dat)==dat.plot[i,]$sample)
  
  #find which peak_indexes for the peaks in that cell type
  peak_index<-dhs.merge.dat[dhs.merge.dat[,cell_col]==1,]$index

  #Calculate enrichment
  a<-length(intersect(peak_index, pcre_index)) #Number of pCRE in DHS peak
  b<-length(intersect(peak_index, non_pcre_index)) #Number of non-pCRE in DHS peak
  c<-nrow(subset(mpra2, mpra_sig%in%c("Enhancer_nSkew", "Enhancer_Skew")))-a #Number of pCRE not in DHS
  d<-nrow(subset(mpra2, mpra_sig=="nEnhancer_nSkew"))-b #Number of non-pCRE not in DHS
  dat.plot[i,]$pcre_fold<-(a/(a+c))/(b/(b+d)) #Calcualte fold enrichment
  dat.plot[i,]$pcre_p<-fisher.test(rbind(c(a,b), c(c, d)), alternative="two.sided")$p.value #Calculate p-value
}

###########################################################################

pcre_p <- dat.plot$pcre_p
   
   precision.BF.dat.dhs <- rbind(precision.BF.dat.dhs, data.frame(k, j, pcre_p)) # makes the data frame used for the heat map
  }
}
names(precision.BF.dat.dhs) <- c("FDR", "BF", "pcre_p")

BF_FDR_CD4_DHS_heat_map <- ggplot(data.frame(precision.BF.dat.dhs), aes(x = as.character(FDR), y = as.character(BF), fill = -log10(pcre_p))) +
  geom_tile() + geom_text(aes(label = round(-log10(pcre_p), digits = 2))) + xlab("Skew FDR") + ylab("BF") + 
  ggtitle("CD4 DHS enrichment BF heatmap") + scale_fill_gradient(low = "gold", high = "firebrick2") 
BF_FDR_CD4_DHS_heat_map

```

```{r, eval=FALSE, echo=FALSE}
# Save the plots
ggsave("Skew_FDR_CD4_DHS_heat_map.png",plot = Skew_FDR_CD4_DHS_heat_map, path = "/nfs/jray/screens/ALL_MPRAs/Ho_et_al_analysis/Downstream_Analysis/precision_and_recall_analysis/plots", width = 8, height = 6)
ggsave("FC_FDR_CD4_DHS_heat_map.png",plot = FC_FDR_CD4_DHS_heat_map, path = "/nfs/jray/screens/ALL_MPRAs/Ho_et_al_analysis/Downstream_Analysis/precision_and_recall_analysis/plots", width = 8, height = 6)
ggsave("BH_FDR_CD4_DHS_heat_map.png",plot = BH_FDR_CD4_DHS_heat_map, path = "/nfs/jray/screens/ALL_MPRAs/Ho_et_al_analysis/Downstream_Analysis/precision_and_recall_analysis/plots", width = 8, height = 6)
ggsave("BF_FDR_CD4_DHS_heat_map.png",plot = BF_FDR_CD4_DHS_heat_map, path = "/nfs/jray/screens/ALL_MPRAs/Ho_et_al_analysis/Downstream_Analysis/precision_and_recall_analysis/plots", width = 8, height = 6)
```


![*Skew FDR CD4 DHS enrichment heat map*](/nfs/jray/screens/ALL_MPRAs/Ho_et_al_analysis/Downstream_Analysis/precision_and_recall_analysis/plots/Skew_FDR_CD4_DHS_heat_map.png){width=px}
![*FC FDR CD4 DHS enrichment heat map*](/nfs/jray/screens/ALL_MPRAs/Ho_et_al_analysis/Downstream_Analysis/precision_and_recall_analysis/plots/FC_FDR_CD4_DHS_heat_map.png){width=px}

![*BH FDR CD4 DHS enrichment heat map*](/nfs/jray/screens/ALL_MPRAs/Ho_et_al_analysis/Downstream_Analysis/precision_and_recall_analysis/plots/BH_FDR_CD4_DHS_heat_map.png){width=px}

![*BF FDR CD4 DHS enrichment heat map*](/nfs/jray/screens/ALL_MPRAs/Ho_et_al_analysis/Downstream_Analysis/precision_and_recall_analysis/plots/BF_FDR_CD4_DHS_heat_map.png){width=px}


